%start s

S : ALGO LEXV_ID CORPS;
CORPS : DEBUT PROG FIN;
PROG : DECLARATION | AFFECTATION | DECLARATION_SOUS_PROGRAMME | APPEL | STRUCTURE_DE_CONTROLE | BREAK | PROG PROG;

VAL : LEXV_NUMBER | BOOLEN_TRUE | BOOLEN_FALSE;
VAR : LEXV_ID | APPEL;
OPERATEUR : PLUS | MOINS | FOIS | DIV | MOD;

DECLARATION : DEC LEXV_ID DP TYPE_DEC PV
            | DEC LEXV_ID DP TYPE_DEC AF EXPRESSION PV;

EXPRESSION : VAR { $$ = $1; }
            | VAL { $$ = $1; }
            | APPEL { $$ = $1; }
            | EXPRESSION PLUS EXPRESSION { $$ = $1 + $3; }
            | EXPRESSION MOINS EXPRESSION { $$ = $1 - $3; }
            | EXPRESSION FOIS EXPRESSION { $$ = $1 * $3; }
            | EXPRESSION DIV EXPRESSION { $$ = $1 / $3; }
            | EXPRESSION MOD EXPRESSION { $$ = $1 % $3; }
            | PAR_OU EXPRESSION PAR_FER { $$ = $2; };

PARAMETRE_APPEL : VAR | VAL | PARAMETRE_APPEL VIRGL PARAMETRE_APPEL;
PARAMETRE_SP : LEXV_ID DP CONSTANCE TYPE | PARAMETRE_SP VIRGL PARAMETRE_SP;

CONDITION: EXPRESSION | EXPRESSION COMPARATIF EXPRESSION | CONDITION OPERATEUR_LOGIQUE CONDITION;
RENVOI: RETURN EXPRESSION PV { $$ = $2; };

TYPE_DEC : TYPE | TABLEAU_DE ENTIER_NATUREL TYPE;
APPEL : LEXV_ID PAR_OU PARAMETRE_APPEL PAR_FER | LEXV_ID PAR_OU PAR_FER;

AFFECTATION : LEXV_ID AF EXPRESSION PV { printf("%d vaut maintenant %d\n", $1, $3); };

DECLARATION_SOUS_PROGRAMME : DECLARATION_PROCEDURE | DECLARATION_FONCTION;

DECLARATION_PROCEDURE : PROCEDURE LEXV_ID PAR_OU PARAMETRE_SP PAR_FER CORPS;
DECLARATION_FONCTION : FONCTION LEXV_ID PAR_OU PARAMETRE_SP PAR_FER DEBUT PROG RENVOI FIN;

STRUCTURE_DE_CONTROLE : IF_ | WHILE_DO_ | DO_WHILE_ | WHILE_TRUE_ | FOR_

ELSE_IF_ : ELSE_IF PROG | ELSE_IF PROG ELSE_IF_
IF_: IF PAR_OU CONDITION PAR_FER PROG ENDIF
    | IF PAR_OU CONDITION PAR_FER PROG ELSE_IF_ ENDIF
    | IF PAR_OU CONDITION PAR_FER PROG ELSE_IF_ ELSE PROG ENDIF
    | IF PAR_OU CONDITION PAR_FER PROG ELSE PROG ENDIF;

WHILE_DO_ : WHILE PAR_OU CONDITION PAR_FER DO PROG END_DO;

DO_WHILE_ : REPEAT PROG UP_TO PAR_OU CONDITION PAR_FER;

WHILE_TRUE_ : WHILE_TRUE PROG END_WHILE_TRUE;

FOR_ : FOR PAR_OU LEXV_ID VARIANT_OF EXPRESSION TO EXPRESSION PAR_FER DO PROG END_DO;
